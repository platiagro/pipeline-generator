# This workflow will install Python dependencies, run tests and lint with a single version of Python
# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions

name: Python application

on:
  push:
    branches: [ feature/test-training ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    services:
      mysql:
        image: mysql:5.7
        env:
          MYSQL_ALLOW_EMPTY_PASSWORD: yes
          MYSQL_DATABASE: platiagro
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3

    steps:
    # - name: Code review tips
    #   uses: unsplash/comment-on-pr@master
    #   if: ${{ github.event_name == 'pull_request' && github.event.action == 'opened' }}
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    #   with:
    #     msg: |
    #       ## Dicas para revisão de código

    #       ### Commits
    #       - Título (1a linha do commit): apresentar resumo do que foi alterado/adicionado/removido.
    #         ex: adiciona action que salva parametros no backend; exibe rótulo no componente de selecao de dataset;
    #       - Descrição (outras linhas): dar mais detalhes de cada alteração:
    #         - motivos das alterações
    #           ex: havia um bug que causava...; nova funcionalidade que faz isso...; código foi movido para...;
    #         - bibliotecas adicionadas e versões (requirements.txt)
    #           ex: atualiza para Kubeflow Pipelines SDK 1.0.3;
    #         - testes unitários criados/alterados
    #           ex: adiciona testes para a API GET /trainings/{trainingId}/operators/{operatorId};
    #         - alterações do `swagger.yaml`
    #           ex: adiciona documentação para `PUT /trainings/{trainingId}`
    #       - Mensagens auto-explicativas! Quem revisa o código deve entender o que foi feito (e porque foi feito) **sem perguntar para quem fez o commit**.
    #       - Não devem ter conflitos. Solicitar que sejam resolvidas as ocorrências de "This branch has conflicts that must be resolved".

    #       ### SonarCloud Quality Gate
    #       - Coverage > 80.0%, e sempre que possível = 100%
    #       - 0 Bugs, 0 Code Smells, 0 Vulnerabilities
    #       - São permitidos os seguintes Security Hotspots:
    #         - Make sure this permissive CORS policy is safe here.
    #         - Make sure publicly writable directories are used safely here.
    #         - Using http protocol is insecure. Use https instead.
    #         - Make sure disabling CSRF protection is safe here.

    #       ### Build Github actions COM SUCESSO

    #       ### Python
    #       - Usar Python 3.6
    #       - Remover `print`.
    #       - Não deixar código-fonte comentado.
    #       - f-string `f'text-{variable}'` é melhor que `'text-{}'.format(variable)` e `'text-' + variable`
    #       - async/await NÃO EXISTEM no Python3.6
    #       - Métodos que são chamados de outros arquivos `.py` **DEVEM TER Docstring**.
    #       - Usar Google Style Python Docstring: https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html
    #       - Usar sempre import absoluto.
    #         ex: `from pipelines.database import Base` (BOM), `from .database import Base (RUIM)`
    # - name: Set output variables
    #   id: vars
    #   run: |
    #     echo ${{ github.ref }}
    #     if [ ${{ github.ref }} = "refs/heads/master" ]; then
    #       echo ::set-output name=TAG::0.1.0
    #     else
    #       echo ::set-output name=TAG::0.1.0-SNAPSHOT
    #     fi
    #     echo ::set-output name=BRANCH::${{ github.ref }}
    #     echo ::set-output name=COMMIT::${{ github.sha }}
    # - uses: actions/checkout@v2
    # - name: Set up Python 3.6
    #   uses: actions/setup-python@v1
    #   with:
    #     python-version: 3.6
    # - name: Run MinIO image
    #   run: |
    #     docker run -d -p 9000:9000 \
    #     -e "MINIO_ACCESS_KEY=$MINIO_ACCESS_KEY" \
    #     -e "MINIO_SECRET_KEY=$MINIO_SECRET_KEY" \
    #     minio/minio:RELEASE.2018-02-09T22-40-05Z server /data
    #   env:
    #     MINIO_ACCESS_KEY: minio
    #     MINIO_SECRET_KEY: minio123
    # - name: Run jupyter image
    #   run: docker run --name jupyter -d -p 8888:8888 jupyter/base-notebook start-notebook.sh --NotebookApp.token=''
    - name: Install Kubernetes 1.15.7
      run: |
        curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add
        sudo swapoff -a
        sudo apt-add-repository "deb http://apt.kubernetes.io/ kubernetes-xenial main"
        sudo apt-get install -y --allow-downgrades kubeadm=1.15.7-00 kubelet=1.15.7-00 kubectl=1.15.7-00
        sudo kubeadm init
        sudo mkdir -p $HOME/.kube
        sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
        sudo chown $(id -u):$(id -g) $HOME/.kube/config
        kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"
        kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=admin --user=kubelet --group=system:serviceaccounts
        kubectl taint nodes --all node-role.kubernetes.io/master-
        while [ $(kubectl get node |tail -n 1|awk '{print $2}') != "Ready" ]; do echo waiting nodes to be ready...; sleep 1; done 
    - name: Create Persistent Volumes
      run: |
        for i in `seq 1 10`; do
          sudo mkdir -p "/mnt/disks/vol-$i"
          sudo mount -t tmpfs -o size=20G "vol-$i" "/mnt/disks/vol-$i"
        done
        cat <<EOF | kubectl apply -f -
          kind: StorageClass
          apiVersion: storage.k8s.io/v1
          metadata:
            name: local-storage
          provisioner: kubernetes.io/no-provisioner
          reclaimPolicy: Delete
        EOF
        kubectl patch storageclass local-storage -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'
        cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: local-provisioner-config
            namespace: default
            labels:
              heritage: "Tiller"
              release: "release-name"
              chart: provisioner-2.3.2
          data:
            storageClassMap: |
              local-storage:
                hostDir: /mnt/disks
                mountDir: /mnt/disks
                blockCleanerCommand:
                  - "/scripts/shred.sh"
                  - "2"
                volumeMode: Filesystem
        EOF
        cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: DaemonSet
          metadata:
            name: local-volume-provisioner
            namespace: default
            labels:
              app: local-volume-provisioner
              heritage: "Tiller"
              release: "release-name"
              chart: provisioner-2.3.2
          spec:
            selector:
              matchLabels:
                app: local-volume-provisioner
            template:
              metadata:
                labels:
                  app: local-volume-provisioner
              spec:
                serviceAccountName: local-storage-admin
                containers:
                  - image: "quay.io/external_storage/local-volume-provisioner:v2.3.2"
                    name: provisioner
                    securityContext:
                      privileged: true
                    env:
                    - name: MY_NODE_NAME
                      valueFrom:
                        fieldRef:
                          fieldPath: spec.nodeName
                    - name: MY_NAMESPACE
                      valueFrom:
                        fieldRef:
                          fieldPath: metadata.namespace
                    - name: JOB_CONTAINER_IMAGE
                      value: "quay.io/external_storage/local-volume-provisioner:v2.3.2"
                    volumeMounts:
                      - mountPath: /etc/provisioner/config
                        name: provisioner-config
                        readOnly: true
                      - mountPath: /dev
                        name: provisioner-dev
                      - mountPath: /mnt/disks
                        name: disks
                        mountPropagation: "HostToContainer"
                volumes:
                  - name: provisioner-config
                    configMap:
                      name: local-provisioner-config
                  - name: provisioner-dev
                    hostPath:
                      path: /dev
                  - name: disks
                    hostPath:
                      path: /mnt/disks
        EOF
        cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: local-storage-admin
            namespace: default
            labels:
              heritage: "Tiller"
              release: "release-name"
              chart: provisioner-2.3.2
        EOF
        cat <<EOF | kubectl apply -f -
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: local-storage-provisioner-pv-binding
            labels:
              heritage: "Tiller"
              release: "release-name"
              chart: provisioner-2.3.2
          subjects:
          - kind: ServiceAccount
            name: local-storage-admin
            namespace: default
          roleRef:
            kind: ClusterRole
            name: system:persistent-volume-provisioner
            apiGroup: rbac.authorization.k8s.io
        EOF
        cat <<EOF | kubectl apply -f -
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRole
          metadata:
            name: local-storage-provisioner-node-clusterrole
            labels:
              heritage: "Tiller"
              release: "release-name"
              chart: provisioner-2.3.2
          rules:
          - apiGroups: [""]
            resources: ["nodes"]
            verbs: ["get"]
        EOF
        cat <<EOF | kubectl apply -f -
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: local-storage-provisioner-node-binding
            labels:
              heritage: "Tiller"
              release: "release-name"
              chart: provisioner-2.3.2
          subjects:
          - kind: ServiceAccount
            name: local-storage-admin
            namespace: default
          roleRef:
            kind: ClusterRole
            name: local-storage-provisioner-node-clusterrole
            apiGroup: rbac.authorization.k8s.io
        EOF
        sleep 10
        kubectl wait --for=condition=Ready pods --all
    - name: Install Kubeflow Pipelines
      run: |
        kubectl apply -k "github.com/kubeflow/pipelines/manifests/kustomize/cluster-scoped-resources?ref=$PIPELINE_VERSION"
        kubectl wait --for condition=established --timeout=60s crd/applications.app.k8s.io
        kubectl apply -k "github.com/kubeflow/pipelines/manifests/kustomize/env/platform-agnostic?ref=$PIPELINE_VERSION"
        kubectl -n kubeflow wait applications/pipeline --for condition=Ready --timeout=1800s
        kubectl -n kubeflow patch svc ml-pipeline --patch \
          '{ "spec": { "type": "NodePort", "ports": [ { "nodePort": 30000  , "port": 8888, "protocol": "TCP", "targetPort": 8888 } ] } }'
      env:
        PIPELINE_VERSION: 0.5.1
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install .
    - name: Test with pytest
      run: |
        pip install pytest pytest-cov
        coverage erase
        coverage run --branch --source=pipelines -m pytest
        coverage xml -i
      env:
        MINIO_ENDPOINT: localhost:9000
        MINIO_ACCESS_KEY: minio
        MINIO_SECRET_KEY: minio123
        MYSQL_DB_HOST: localhost
        MYSQL_DB_NAME: platiagro
        MYSQL_DB_USER: root
        KF_PIPELINES_ENDPOINT: localhost:30000/pipeline
        JUPYTER_ENDPOINT: http://localhost:8888
    # - name: SonarCloud Scan
    #   uses: sonarsource/sonarcloud-github-action@master
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    # - name: Build and push image
    #   uses: docker/build-push-action@v1
    #   with:
    #     username: ${{ secrets.DOCKER_USERNAME }}
    #     password: ${{ secrets.DOCKER_PASSWORD }}
    #     registry: registry.hub.docker.com
    #     repository: platiagro/pipelines
    #     tags: ${{ steps.vars.outputs.TAG }}
    #     build_args: COMMIT=${{ steps.vars.outputs.COMMIT }},BRANCH=${{ steps.vars.outputs.BRANCH }}
